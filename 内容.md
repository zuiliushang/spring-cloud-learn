# Spring Cloud

版本:Dalston.SR3

Spring Cloud是一个快速构建分布式系统中常见模式的工具(例如配置管理，服务发现，断路器，智能路由，微代理，控制总线)。并协调分布式系统boiler plate patterns。使用Spring Cloud的开发人员可以快速创建服务和应用。并且在任何的分布式系统中良好工作，包括开发人员的电脑，数据中心，和管理平台如Cloud Foundry。

## 功能

Spring Cloud 致力于常见情况使用经验和扩展机制来提供良好的决策体验(就是一套方案)。

- 分布式/版本化配置
- 服务注册和发现
- 路由
- 服务到服务调用
- 读取平衡
- 断路器
- 分布式信息

## Cloud Native 应用

Cloud Native 是一种应用发展风格,这种风格更容易适应持续生产和值驱动发展的最佳实践。一个相关的学科是构建12-factor Apps，其中的开发实践与交付和运营目标一致。例如使用声明式编程和管理和监控。Spring Cloud促进这些发展风格通过多种特殊方式并且初始是一系列所有在分布式系统这种被需要或者不被需要的组件的功能。(靠 应该就是说Spring Cloud其实就是注入的一系列功能的bean)。

这些功能在Spring Boot(Spring Cloud的基础)中被覆盖。大部分已经被交付通过Spring Cloud作为两个类库:Spring Cloud Context和Spring Cloud Common。Spring Cloud Context 提供工具和特别的服务为了让```ApplicationContext```实现配置一个Spring Cloud应用的上下文(启动上下文，加密，作用域刷新和环境endpoint)。Spring Cloud Commons 是一组抽象和普通的类使用在不同的Spring Cloud实现(如 Spring Cloud Netflix Spring Cloud Consul)中。

如果你捕获到一个异常叫做"Illegal key size"并且你用的是Sun的JDK，你需要安装Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files.

### Spring Cloud Context: Application Context Services

Spring Boot有一个既定的图纸如何通过Spring构建一个应用:例如它有基础配置文件固定位置。并且通常管理和监控任务。Spring Cloud在最上层添加一些功能可能所有的系统中的组件会用到或者可能需要到。

#### BootStrap Application Context

一个Spring Cloud应用通过创建一个启动上下文来操作，这个上下文是主程序的父上下文。它负责通过外来资源来读取配置属性。并且在本地额外配置文件解密属性。两个上下文共享一个Environment(任何Spring应用的额外属性存放地方)。启动属性被添加在高优先级中，所以他们默认不能在本地配置中被重写；

启动上下文使用一个不同于主应用上下文的定位额外配置的约定。所以可以使用bootstrap.yml而不是用application.yml来保持额外的配置来提供启动和主上下文很好的分离。(就是让你把springcloud的优先级高的配置扔在bootstrap.yml不要扔在application.yml)如：

bootstrap.yml
<pre>
spring:
 application:
  name: foo
 cloud:
  config:
   uri: ${SPRING_CONFIG_URI:http://localhost:8888}
</pre>

一个好主意是设置```spring.application.name```(放在bootstrap.yml或者application.yml)如果你的应用需要来自服务器的任何特定于应用程序的配置。

你可以完整关闭启动通道通过设置```spring.cloud.bootstrap.enabled=false```

#### 应用上下文调层次

如果你通过```SpringApplication```或```SpringApplicationBuilder```创建的引用上下文。那么启动上下文将会添加在这些上下文之上。子上下文会继承到启动上下文的属性。相较于没有Spring Cloud配置的上下文。额外的属性有：

- ```bootstrap```：如果有一个```PropertySourceLocators```在启动上下文被发现那么这个配置就会被```CompositeProertySource```最优先发现，并且为非空的属性。

- ```applicationConfig```:[classpath:bootstrap.yml]\(友好如果一个spring文件激活\)。如果你有一个bootstrap.yml(或properties)然后这些属性将会被用来配置启动上下文。并且他们加入子上下文当它们父上下文被设置。它们的优先级比```application.yml```低。并且其他属性也可以被添加成为创建一个Spring Boot 应用进程的一部分。

因为排序规则```bootstrap```属性优先级最高，但是注意并不是```bootstrap.yml```数据都是，有些优先级低但是被默认设置。

你可以继承上下文层次通过设置任何```ApplicationContext```你创建的父上下文、例如使用自己的接口或者使用```SpringApplicationBuilder```便捷方法(```parent()```，```child()```和```sibling()```)。启动上下文将最先最优先被加载，调用栈的每个上下文都有他们自己的启动属性来避免一些启动项无意的让父属性覆盖了子属性。每个上下文也有一个不同的```spring.application.name```和一个不同启动属性当有一个配置服务器。正常的spring 应用上下文举动遵循举动规则:子上下文覆盖父上下文的属性通过名字也可以通过属性资源名(如果子有一个属性资源的名称和父一样,那父不会覆盖子)。

注意```SpringApplicationBuilder```允许你共享一个 ```Environment```在整个调用栈里。但是这不是默认。因此，兄弟级上下文不需要拥有相同的配置文件或属性源，即使它们共有一些父属性。

#### 修改启动属性的位置

```bootstrap.yml```位置可以使用```spring.cloud.bootstrap.name```(默认叫bootstrap)或者```spring.cloud.bootstrap.location```(默认为空)。例如在系统属性中。这些属性都有类似的```spring.config.*```相同名字的属性。并且它们会被设置到启动```ApplicationContext```通过在它们的```Environment```设置。如果有一个激活的profile(来自```spring.profiles.active```或者通过```Environment```API建立的)那么这些属性也会被读取进去，就像传统的springboot应用一样。例如```bootstrap-development.properties```来自development profile.

#### 覆盖启动属性

一些资源加入你的应用通过上下文通常是"启动"（例如从一个配置服务器）并且默认他们不能在本地覆盖,除了命令行。如果你想要允许应用来如果启动属性通过自己的系统环境或者配置文件,那么启动属性必须授予允许通过设置```spring.cloud.config.allowOverride=true```(这个在本地不工作).一旦这个属性被设置那么有一些细粒度的设置来控制启动属性依赖系统属性的位置合应用本地配置:```spring.cloud.config.overrideNone=true```来覆盖一些本地属性,```spring.cloud.config.overrideSystemProperties=false```如果只是系统属性和环境变量可以被覆盖，但本地配置文件不可以。

#### 自定义启动配置

启动上下文可以被自定义来做你想要的任何事情通过添加键值对到```/META-INF/spring.factories```，key为```org.springframework.cloud.bootstrap.BootstrapConfiguration```。这是一个以逗号分隔的Spring```@Configuration```类列表(将会被创建进入这个context)。任何的bean你想要启用在主要的应用上下文中注入可以创建在这里。并且特别使用```@Bean```能够被```ApplicationContextInitializer```标注。如果你想要慢点注入，使用```@Order```
> 要特别小心在添加定制化```BootstrapConfiguration```你添加的类没有```@ComponentScanned```到你的主应用上下文是错误的。使用一个单独的包名，用于未被您```@ componentscan```或```@ springbootapplication```注释的配置类所覆盖的引导配置类。

#### 自定义启动属性资源

外部配置的默认属性资源被配置服务器的启动进程添加，但是你可以添加额外的资源通过添加```PropertySourceLocator```的bean到启动上下文(例如```spring.factories```)。你可以使用这个来插入额外的属性通过不同的服务器或者数据库实例。

例如,考虑以下简单的自定义定位器:

<pre>
public class CustomPropertySourceLocator implements PropertySourceLocator{
	@Override
	public PropertySource<?> locate(Environment environment) {
		return new MapPropertySource("customProperty", 
				Collections.singletonMap("property.from.sample.custom.source", "worked as intend"));
	}
}
</pre>

```Environment```传递的是```ApplicationContext```将被创建。也就是说，我们提供额外的属性来源。它将已有自己正常spring boot提供的属性所以你可以使用这些来定位一个资源属性到这个```Environment```中(例如通过使用key ```spring.application.name```,这个已经在默认配置服务器的时候定位生成了)

如果你创建一个jar里面有class，你添加一个```META-INF/spring.factories```包括:

<pre>
org.springframework.cloud.bootstrap.BootstrapConfituration=sample.custom.CustomPropertySourceLocator
</pre>

然后自定义属性```PropertySource```将会存在于任何在自己的classpath下包括这个jar的应用。

#### 环境改变

应用将会监听一个```EnvironmentChangeEvent```并且响应变化在一个标准方式组合(额外的```ApplicationListeners```用户可以添加一个```@Beans```在正常情况下)。当一个```EnvironmentChangeEvent```被监视它将会有一系列的键值被改变，应用将会使用这些到:

- 重新绑定任何```@ConfigurationProperties```bean在上下文

- 任何属性在```logging.level```设置日志等级

注意在```Environment```,配置客户端不为更改进行默认的轮询，并且通常我们不会建议使用方法来检测变化(监管你可能设置到一个```@Scheduled```注解)。如果你有一个伸缩性的客户端应用则广播```EnvironmentChangeEvent```到所有的实例比让他们轮训这个变化更好(例如使用```Spring Cloud Bus```)。

```EnvironmentChangeEvent```覆盖一个关于更新用例的大的类,和你通常改变一个```Environment```并且推送事件一样大(这些API都是共有并且是Spring的重要部分)。你可以验证改变绑定在```@ConfigurationProperties```bean通过访问```/configprops```端点(正常的Spring Boot执行器功能)。例如一个```DataSource```可以有它的```maxPoolSize```在运行时间改变(默认```DataSource```是一个```@ConfigurationProperties```bean 被Spring Boot创建)并且动态成长能力。重新绑定```@ConfigurationProperties```不需要覆盖其他另一类大型用例，您需要对refresh进行更多的控制，以及在整个ApplicationContext中需要更改为原子的地方。

#### 刷新作用域

一个Spring```@Bean```被标记位```@RefreshScope```并将特别的检查当有一个配置被改变。这个解决了一个问题关于仅在它们初始化阶段获取配置的有状态bean注入。例如,如果一个```DataSource```已经连接了当数据库的URL在```Environment```中改变。我们特别想要保持这些连写可以完成它们的工作。然后下一次有人从池中借用一个连接，他就会得到一个新的URL。

刷新作用域Bean是懒惰代理当它们被使用的时候才初始化(例如一个方法被调用)并且这个作用域作为一个初始值被缓存。为了让一个bean重新初始化在下一个方法只需要让这个缓存失效即可。

```RefreshScope```是一个上下文的bean并且有一个public方法```refreshAll()```来刷新所以作用域里的bean通过清除目标的缓存。通用有一个```refresh(String)```方法来刷新一个指定的bean通过名称。这个方法暴露在```/refresh```端点(通过HTTP或者JMX)

>注意:```@RefreshScope```工作（专门的）在一个```@Configuration```类，但是它可能引起一个意外的举动:例如它不意味着所有定义的```@Bean```都是```@RefreshScope```。特别，任何依赖这些bean不能依赖